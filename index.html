<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>è´ªåƒè›‡ Â· æ‰‹æœºç‰ˆ</title>
<style>
  :root {
    --bg:#fbfcff;
    --fg:#2b2f36;
    --muted:#697287;
    --card:#ffffff;
    --chip:#f3f6ff;
    --chip-border:#dee6ff;
    --grid:#eef2ff;
    --btn:#fff3f8;
    --btn-border:#ffd2e7;
    --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  .wrap{display:flex;flex-direction:column;min-height:100%;gap:12px;padding:12px;
    padding-bottom: env(safe-area-inset-bottom, 12px)}

  header{
    background:var(--card); border:1px solid var(--chip-border); border-radius:14px;
    padding:8px 10px; display:flex; align-items:center; gap:10px; flex-wrap:nowrap;
    box-shadow:0 6px 18px rgba(88,120,255,.08)
  }
  h1{font-size:16px;margin:0;font-weight:700;letter-spacing:.2px;white-space:nowrap}

  /* é¡¶éƒ¨èœå•ï¼šå•è¡Œ + æ¨ªå‘å¯æ»šåŠ¨ */
  .stats{
    display:flex; gap:8px; align-items:center; flex:1 1 auto;
    overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch; scrollbar-width:none;
  }
  .stats::-webkit-scrollbar{display:none}

  .pill{
    padding:6px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--chip-border);
    display:inline-flex;gap:6px;align-items:center;white-space:nowrap;flex:0 0 auto;
  }
  .pill .emoji{font-size:16px}
  select{
    appearance:none;border:1px solid var(--btn-border);background:var(--btn);color:var(--fg);
    padding:8px 12px;border-radius:12px;font-size:14px;white-space:nowrap
  }

  .canvas-wrap{position:relative;flex:1;display:flex;align-items:center;justify-content:center}
  canvas{
    background:
      linear-gradient(0deg,transparent 24%,var(--grid) 25%,var(--grid) 26%,transparent 27%,transparent 74%,var(--grid) 75%,var(--grid) 76%,transparent 77%),
      linear-gradient(90deg,transparent 24%,var(--grid) 25%,var(--grid) 26%,transparent 27%,transparent 74%,var(--grid) 75%,var(--grid) 76%,transparent 77%);
    background-size:40px 40px; border:1px solid var(--chip-border); border-radius:16px;
    box-shadow:0 10px 30px rgba(88,120,255,.10)
  }
  .overlay{
    position:absolute;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(250,252,255,.65);backdrop-filter:saturate(120%) blur(6px);
    border-radius:16px; cursor:pointer; color:var(--muted); text-align:center; padding:16px;
  }
  .overlay.show{display:flex}
  .card{background:#ffffff;border:1px solid var(--chip-border);border-radius:16px;padding:18px 16px;min-width:240px}
  .title{font-size:18px;margin:0 0 6px;color:var(--fg);font-weight:700}
  .sub{margin:0 0 6px;font-size:14px;color:var(--muted)}

  .ctl{display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,64px);gap:10px;
       margin:10px auto 0;justify-content:center}
  .key{
    background:#fff;border:1px solid var(--chip-border);border-radius:12px;
    display:flex;align-items:center;justify-content:center;font-size:16px;user-select:none;color:var(--fg)
  }
  .key:active{transform:scale(.98); background:#f7faff}

  @media (max-width: 360px){
    h1{font-size:14px}
    select{font-size:12px;padding:7px 10px}
    .pill{padding:5px 8px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ğŸ è´ªåƒè›‡</h1>
      <div class="stats" id="topBar">
        <div class="pill"><span class="emoji">ğŸ¯</span>åˆ†æ•° <span id="score">0</span></div>
        <div class="pill"><span class="emoji">ğŸ†</span>æœ€é«˜ <span id="best">0</span></div>
        <label class="pill" style="gap:8px">
          <span class="emoji">âš¡</span>é€Ÿåº¦
          <select id="speedSel" title="é€Ÿåº¦">
            <option value="5">å®¹æ˜“</option>
            <option value="8" selected>æ™®é€š</option>
            <option value="12">å›°éš¾</option>
          </select>
        </label>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="game" width="400" height="400" aria-label="æ¸¸æˆç”»å¸ƒ" role="img"></canvas>
      <div class="overlay" id="overlay" title="ç‚¹å‡»å¼€å§‹ / ç»§ç»­ / é‡å¼€">
        <div class="card">
          <p class="title" id="ovTitle">å¼€å§‹æ¸¸æˆ</p>
          <p class="sub" id="ovSub">ç‚¹ä»»æ„ä½ç½®æˆ–æŒ‰æ–¹å‘é”®å¼€å§‹</p>
        </div>
      </div>
    </div>

    <!-- åå­—é”®ï¼šä¸Š/å·¦/å¼€å§‹/å³/ä¸‹ -->
    <div class="ctl" aria-label="è§¦æ§æ–¹å‘é”®">
      <div></div><button class="key" data-dir="up">â†‘ ä¸Š</button><div></div>
      <button class="key" data-dir="left">â† å·¦</button>
      <button class="key" data-dir="start">å¼€å§‹/æš‚åœ</button>
      <button class="key" data-dir="right">â†’ å³</button>
      <div></div><button class="key" data-dir="down">â†“ ä¸‹</button><div></div>
    </div>
  </div>

<script>
(() => {
  /* ====== é¢œè‰²ä¸å¸¸é‡ ====== */
  const SNAKE_COLOR = '#0b3d2e';        // å¢¨ç»¿
  const SNAKE_HEAD_COLOR = '#11684d';   // æ·±å¢¨ç»¿
  const FOOD_COLOR = '#ffc0cb';         // æµ…ç²‰
  const SPECIAL_EMOJI = 'ğŸ“';
  const SPECIAL_BONUS = 2;

  /* ====== DOM ====== */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovSub = document.getElementById('ovSub');
  const speedSel = document.getElementById('speedSel');

  /* ====== è‡ªé€‚åº”ç”»å¸ƒ ====== */
  const gridCount = 20;
  let cellSize = 20;
  function fitCanvas() {
    const maxW = Math.min(window.innerWidth - 24, 560);
    const maxH = Math.min((window.innerHeight * 0.6), 560);
    const size = Math.floor(Math.min(maxW, maxH));
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    canvas.width = Math.floor(size * dpr);
    canvas.height = Math.floor(size * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cellSize = Math.max(14, Math.floor(size / gridCount));
  }

  /* ====== é€Ÿåº¦ ====== */
  let speed = Number(speedSel.value);   // æ­¥/ç§’
  let stepTime = 1000 / speed;

  /* ====== çŠ¶æ€ ====== */
  let snake, dir, nextDir, food, special, score, best, running, dead, movedSinceDir;
  let foodsSinceSpecial;
  let lastTime = 0, acc = 0;

  /* ====== WebAudioï¼šç°ä»£æ„Ÿ BGMï¼ˆå¤šè½¨ï¼‰+ SFX ====== */
  let audioCtx;
  let tempo = 110;                // BPM
  const sixteenth = 60/tempo/4;   // 16åˆ†éŸ³ç¬¦æ—¶é•¿
  let nextNoteTime = 0;           // ä¸‹ä¸€ä¸ªéŸ³çš„æ—¶é—´
  let scheduleTimer = null;       // è°ƒåº¦å™¨
  let noteIndex = 0;              // 16åˆ†éŸ³ç¬¦è®¡æ•°

  function initAudio(){
    if(!audioCtx){
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
    }
    if(audioCtx.state === 'suspended'){ audioCtx.resume(); }
  }

  function envGain(t0, a=0.005, d=0.08, s=0.0008, r=0.08, peak=0.3){
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(peak, t0 + a);
    g.gain.exponentialRampToValueAtTime(s, t0 + a + d);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + a + d + r);
    return g;
  }

  function oscAt(type, freq, t0, dur, vol=0.2){
    const o = audioCtx.createOscillator();
    o.type = type; o.frequency.setValueAtTime(freq, t0);
    const g = envGain(t0, 0.004, 0.05, 0.001, dur, vol);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0); o.stop(t0 + dur + 0.02);
  }

  function kick(t){
    const o = audioCtx.createOscillator();
    const g = envGain(t, 0.002, 0.06, 0.001, 0.12, 0.8);
    o.type='sine';
    o.frequency.setValueAtTime(140,t);
    o.frequency.exponentialRampToValueAtTime(40, t+0.12);
    o.connect(g).connect(audioCtx.destination);
    o.start(t); o.stop(t+0.14);
  }
  function snare(t){
    const bufferSize = audioCtx.sampleRate * 0.12;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * (1 - i/bufferSize); }
    const src = audioCtx.createBufferSource(); src.buffer = buffer;
    const g = envGain(t, 0.001, 0.08, 0.0008, 0.06, 0.35);
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 1800; bp.Q.value=0.6;
    src.connect(bp).connect(g).connect(audioCtx.destination);
    src.start(t); src.stop(t+0.14);
  }
  function hihat(t){
    const bufferSize = audioCtx.sampleRate * 0.05;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1); }
    const src = audioCtx.createBufferSource(); src.buffer = buffer;
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 7000;
    const g = envGain(t, 0.001, 0.02, 0.0008, 0.03, 0.12);
    src.connect(hp).connect(g).connect(audioCtx.destination);
    src.start(t); src.stop(t+0.08);
  }

  // å’Œå£°ç´ æï¼ˆG å¤§è°ƒï¼‰ï¼šä½éŸ³ã€å’Œå¼¦åˆ†è§£ã€ä¸»æ—‹å¾‹éŸ³é˜¶
  const bassRoot = [49, 43, 45, 40]; // G2, D2, E2, C2 (MIDIè¿‘ä¼¼)
  function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }
  const chordArp = [0,7,12,7];        // æ ¹éŸ³åˆ†è§£ï¼ˆäº”åº¦/å…«åº¦ï¼‰
  const scale = [0,2,4,5,7,9,11,12];  // å¤§è°ƒéŸ³é˜¶

  function scheduleNote(t){
    const step = noteIndex % 16;

    // é¼“ï¼šBD on 1&9ï¼ŒSD on 5&13ï¼ŒHiHatæ¯å¶æ•°16åˆ†
    if(step===0 || step===8) kick(t);
    if(step===4 || step===12) snare(t);
    if(step%2===0) hihat(t);

    // ä½éŸ³ï¼šæ¯æ‹è·Ÿéšå’Œå¼¦æ ¹éŸ³
    if(step%4===0){
      const bar = Math.floor(noteIndex/16);
      const rootMidi = bassRoot[(Math.floor(step/4)+bar)%bassRoot.length];
      oscAt('triangle', midiToHz(rootMidi), t, sixteenth*3.5, 0.15);
    }

    // å’Œå¼¦åˆ†è§£ï¼šæ¯æ‹å››è¿éŸ³
    const bar = Math.floor(noteIndex/16);
    const chordRootMidi = 55 + [0, -7, -5, -10][(Math.floor(step/4)+bar)%4]; // ä»¥G3ä¸ºä¸­å¿ƒè½®è½¬
    const arpOffset = chordArp[step%4];
    oscAt('square', midiToHz(chordRootMidi + arpOffset), t, sixteenth*0.9, 0.06);

    // ä¸»æ—‹å¾‹ï¼šæ¯åŠæ‹èµ°éŸ³é˜¶
    if(step%2===0){
      const deg = scale[(Math.floor(step/2)+bar)%scale.length];
      const freq = midiToHz(67 + deg); // 67=G4
      oscAt('square', freq, t, sixteenth*1.2, 0.08);
    }
  }

  function scheduler(){
    while (audioCtx && nextNoteTime < audioCtx.currentTime + 0.1){ // å‰ç»100ms
      scheduleNote(nextNoteTime);
      nextNoteTime += sixteenth;
      noteIndex++;
    }
  }
  function startBgm(){
    initAudio();
    nextNoteTime = audioCtx.currentTime + 0.05;
    if(scheduleTimer) clearInterval(scheduleTimer);
    scheduleTimer = setInterval(scheduler, 25);
  }
  function stopBgm(){
    if(scheduleTimer){ clearInterval(scheduleTimer); scheduleTimer = null; }
  }

  // äº‹ä»¶éŸ³æ•ˆ
  function sfxEat(){
    initAudio();
    const t = audioCtx.currentTime + 0.01;
    oscAt('square', 660, t, 0.08, 0.14);
    oscAt('square', 880, t+0.05, 0.06, 0.10);
  }
  function sfxBerry(){
    initAudio();
    const t = audioCtx.currentTime + 0.01;
    oscAt('square', 784, t, 0.09, 0.16);   // G5
    oscAt('square', 988, t+0.07, 0.09, 0.16); // B5
    oscAt('square', 1175, t+0.14, 0.12, 0.16); // D6
  }
  function sfxOver(){
    initAudio();
    const t = audioCtx.currentTime + 0.02;
    // ä½é¢‘å è½
    const o = audioCtx.createOscillator(); o.type='sawtooth';
    const g = envGain(t, 0.01, 0.25, 0.001, 0.5, 0.4);
    o.frequency.setValueAtTime(220, t);
    o.frequency.exponentialRampToValueAtTime(60, t+0.5);
    o.connect(g).connect(audioCtx.destination); o.start(t); o.stop(t+0.6);
    // å™ªå£°é—·å“
    setTimeout(()=>snare(audioCtx.currentTime+0.02), 60);
  }

  /* ====== æ ¸å¿ƒé€»è¾‘ ====== */
  function reset() {
    const cx = Math.floor(gridCount / 2);
    const cy = Math.floor(gridCount / 2);
    snake = [{x:cx, y:cy}, {x:cx-1, y:cy}, {x:cx-2, y:cy}];
    dir = {x:1, y:0};
    nextDir = {x:1, y:0};
    movedSinceDir = true;
    score = 0;
    foodsSinceSpecial = 0;
    special = null;
    food = null;
    dead = false;
    running = false;
    placeFood();
    updateScore();
    showOverlay('å¼€å§‹æ¸¸æˆ', 'ç‚¹ä»»æ„ä½ç½®æˆ–æŒ‰æ–¹å‘é”®å¼€å§‹');
    stopBgm();
  }

  function updateScore(){
    scoreEl.textContent = score;
    best = Math.max(Number(localStorage.getItem('snake_best') || 0), score);
    localStorage.setItem('snake_best', best);
    bestEl.textContent = best;
  }

  function randomEmptyCell(){
    while(true){
      const x = Math.floor(Math.random()*gridCount);
      const y = Math.floor(Math.random()*gridCount);
      const collideSnake = snake.some(s=>s.x===x && s.y===y);
      const collideFood = food && food.x===x && food.y===y;
      const collideSpec = special && special.x===x && special.y===y;
      if(!collideSnake && !collideFood && !collideSpec) return {x,y};
    }
  }

  function placeFood(){ if(!special) food = randomEmptyCell(); }
  function placeSpecial(){ special = randomEmptyCell(); food = null; } // æœ‰ğŸ“æ—¶ä¸åˆ·æ™®é€šé£Ÿç‰©

  function drawCell(x,y, color){
    ctx.fillStyle = color;
    ctx.fillRect(x*cellSize+2, y*cellSize+2, cellSize-4, cellSize-4);
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (!special && food){ drawCell(food.x, food.y, FOOD_COLOR); }
    if (special){
      ctx.font = `${Math.floor(cellSize*0.9)}px system-ui,emoji`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(SPECIAL_EMOJI, special.x*cellSize + cellSize/2, special.y*cellSize + cellSize/2);
    }
    snake.forEach((s,i)=>{ drawCell(s.x, s.y, i===0 ? SNAKE_HEAD_COLOR : SNAKE_COLOR); });
  }

  function gameOver(){
    dead = true;
    running = false;
    updateScore();
    showOverlay('æ¸¸æˆç»“æŸ', 'ç‚¹ä»»æ„ä½ç½®é‡å¼€');
    stopBgm();
    sfxOver();
  }

  function tick(dt){
    if(!running) return;
    acc += dt;
    while(acc >= stepTime){
      acc -= stepTime;
      step();
    }
    render();
  }

  function step(){
    if (movedSinceDir){ dir = nextDir; movedSinceDir = false; }
    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
    if(head.x<0||head.y<0||head.x>=gridCount||head.y>=gridCount){ gameOver(); return; }
    if(snake.some(s=>s.x===head.x && s.y===head.y)){ gameOver(); return; }

    snake.unshift(head);

    // åƒğŸ“
    if (special && head.x===special.x && head.y===special.y){
      score += SPECIAL_BONUS;
      updateScore();
      special = null;
      snake.push({...snake[snake.length-1]});
      sfxBerry();
      placeFood();
      return;
    }

    // åƒæ™®é€šé£Ÿç‰©
    if(!special && food && head.x===food.x && head.y===food.y){
      score += 1;
      foodsSinceSpecial += 1;
      updateScore();
      sfxEat();
      if (foodsSinceSpecial >= 5){
        foodsSinceSpecial = 0;
        placeSpecial(); // è‡ªåŠ¨éšè—æ™®é€šé£Ÿç‰©
      } else {
        placeFood();
      }
    } else {
      snake.pop();
    }
  }

  /* ====== æ§åˆ¶ ====== */
  function setDir(nx, ny){
    if ((nx === -dir.x && ny === -dir.y) || (nx===dir.x && ny===dir.y)) return;
    nextDir = {x:nx, y:ny};
    movedSinceDir = true;
    if (!running && !dead){ start(); }
    if (dead){ reset(); start(); }
  }

  function start(){
    if(dead) return;
    hideOverlay();
    running = true;
    startBgm();
  }

  function pauseToggle(){
    if(dead) return;
    running = !running;
    overlay.classList.toggle('show', !running);
    ovTitle.textContent = running ? '' : 'å·²æš‚åœ';
    ovSub.textContent = running ? '' : 'ç‚¹ä»»æ„ä½ç½®ç»§ç»­';
    if(running){ startBgm(); } else { stopBgm(); }
  }

  // é”®ç›˜ï¼ˆæ¡Œé¢å¯ç”¨ï¼‰
  window.addEventListener('keydown', (e)=>{
    const k = e.key;
    if (k==='ArrowUp'||k==='w'||k==='W') setDir(0,-1);
    else if (k==='ArrowDown'||k==='s'||k==='S') setDir(0,1);
    else if (k==='ArrowLeft'||k==='a'||k==='A') setDir(-1,0);
    else if (k==='ArrowRight'||k==='d'||k==='D') setDir(1,0);
    else if (k===' ' || k==='Enter') pauseToggle();
  });

  // è§¦æ§æŒ‰é’®
  document.querySelectorAll('.key').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const d = btn.dataset.dir;
      if(d==='up') setDir(0,-1);
      else if(d==='down') setDir(0,1);
      else if(d==='left') setDir(-1,0);
      else if(d==='right') setDir(1,0);
      else if(d==='start') pauseToggle();
    });
  });

  // ç”»å¸ƒæ‰‹åŠ¿ï¼šæ»‘åŠ¨æ¢å‘ï¼›è½»ç‚¹æš‚åœ/ç»§ç»­
  let touchStart = null;
  canvas.addEventListener('touchstart', (e)=>{
    if(e.touches.length===1){
      touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY};
    }
  }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if(!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const min = 20;
    if (Math.max(adx, ady) > min){
      if(adx>ady) setDir(dx>0 ? 1 : -1, 0);
      else setDir(0, dy>0 ? 1 : -1);
    }else{
      pauseToggle();
    }
    touchStart = null;
  });

  // é€Ÿåº¦é€‰æ‹©
  speedSel.addEventListener('change', ()=>{
    speed = Number(speedSel.value);
    stepTime = 1000 / speed;
  });

  // è¦†ç›–å±‚ç‚¹å‡»ï¼šæš‚åœ=ç»§ç»­ï¼›ç»“æŸ=é‡å¼€ï¼›å¼€å§‹=å¼€å§‹
  overlay.addEventListener('click', ()=>{
    if(dead){ reset(); start(); }
    else { start(); }
  });

  function showOverlay(title, sub){
    ovTitle.textContent = title || '';
    ovSub.textContent = sub || '';
    overlay.classList.add('show');
  }
  function hideOverlay(){ overlay.classList.remove('show'); }

  /* ====== å¯åŠ¨å¾ªç¯ ====== */
  window.addEventListener('resize', ()=>{ fitCanvas(); render(); });
  fitCanvas();
  reset();
  let last = 0;
  function loop(ts){
    const dt = last ? (ts - last) : 0;
    last = ts;
    tick(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
